<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: CMContrib | Kevin Mees]]></title>
  <link href="http://kmees.github.com/blog/categories/cmcontrib/atom.xml" rel="self"/>
  <link href="http://kmees.github.com/"/>
  <updated>2012-02-29T15:36:53+01:00</updated>
  <id>http://kmees.github.com/</id>
  <author>
    <name><![CDATA[Kevin Mees]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CMContrib WPF Demo goin' Metro]]></title>
    <link href="http://kmees.github.com/blog/2012/02/26/cmcontrib-wpf-demo-goin-metro/"/>
    <updated>2012-02-26T18:45:00+01:00</updated>
    <id>http://kmees.github.com/blog/2012/02/26/cmcontrib-wpf-demo-goin-metro</id>
    <content type="html"><![CDATA[<p>Inspired by the <a href="https://github.com/Code52/DownmarkerWPF">DownmarkerWPF</a>, I
decided to change the Style of the CMContrib WPF Demo to Metro. I used the same
Metro framework, namely <a href="https://github.com/MahApps/MahApps.Metro">MahApps.Metro</a> as DownmarkerWPF which is really cool. The only control that I wasn't able to 'metroize' was the <em>WebBrowser</em> control which displays the code. Its scrollbars still have the old Windows look. Another small letdown is that there is no free <em>Pivot</em> control available for WPF but it was quite easy to create a simplified version of it which was sufficient for my needs.</p>

<p>Anyway, I'm quite happy with the result especially since this is my first Metro app. Any feedback is appreciated !</p>

<!--more-->


<h2>Metro Style</h2>

<p><img src="/images/posts/wpfdemo_metro.png" width="640" height="480"></p>

<h2>Old Style</h2>

<p><img src="/images/posts/wpfdemo_old.png" width="640" height="480"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Context-Based Views for Dialogs]]></title>
    <link href="http://kmees.github.com/blog/2012/02/24/context-based-views-for-dialogs/"/>
    <updated>2012-02-24T11:32:00+01:00</updated>
    <id>http://kmees.github.com/blog/2012/02/24/context-based-views-for-dialogs</id>
    <content type="html"><![CDATA[<h2>Retrospect</h2>

<p>In my <a href="/projects/cmcontrib.html">CMContrib Project</a> I use a MVVM approach for
showing dialogs to the user. The model for the dialog has a <em>dialog type</em>
(Question, Error,...), a <em>subject</em> (or title), a <em>message</em> and a list of
possible <em>responses</em> the user can choose from. The default response in CMContrib
is an Answer enum with values for <em>Ok, Cancel, Yes</em> and all the other standard
answers but you can also use a complex type as a response.</p>

<p>Here's an example of how to ask the user a question and cancel the coroutine
when the user responses with <em>No</em>.
``` csharp
public override IEnumerable<IResult> AskAQuestion()
{</p>

<pre><code>var question = new Question("The Subject",
    "The Message",
    Answer.Yes,
    Answer.No);

yield return question.AsResult()
    .CancelOnResponse(Answer.No);

// ...
</code></pre>

<p>}
```</p>

<!--more-->


<h2>One View to show them all (again)</h2>

<p>The call <code>.AsResult()</code> on a dialog wraps it in a <code>DialogViewModel</code> which is then
passed to Caliburn.Micro's <code>IWindowManager</code> and shown as a modular dialog. The problem
with that approach is, that the same default view, which is <code>Caliburn.Micro.Contrib.Dialogs.DialogView</code> unless you added a namespace alias, is resolved for all types of dialogs. Now, if you need a special view for, let's say errors only, you are in trouble.</p>

<p>But fear not, because Caliburn already has a solution to that problem, namely <em>view contexts</em>, which are explained <a href="http://devlicio.us/blogs/rob_eisenberg/archive/2010/11/18/caliburn-micro-soup-to-nuts-part-6d-a-billy-hollis-hybrid-shell.aspx">here</a>. Since each dialog already has a <em>dialog type</em> we can use that as our view context. The change to show the context based view instead of the default view couldn't be easier, it's just one line in the <code>DialogResult</code>
``` csharp
public IEnumerable<IResult> Execute()
{</p>

<pre><code>IDialogViewModel&lt;TResponse&gt; vm = _locateVM();
vm.Dialog = Dialog;

// ommitted unrelevant parts

// show without context
// Micro.Execute.OnUIThread(() =&gt; IoC.Get&lt;IWindowManager&gt;().ShowDialog(vm));
Micro.Execute.OnUIThread(() =&gt; IoC.Get&lt;IWindowManager&gt;().ShowDialog(vm, Dialog.DialogType));
</code></pre>

<p>}
<code>``
Now the default view for an _Error_ is</code>Caliburn.Micro.Contrib.Dialogs.Error<code>.
Okay cool, but what happens if we want to show a _Question_? Well, we get an
error because there is looks for the view
</code>Caliburn.Micro.Contrib.Dialogs.Question<code>which doesn't exist and which we don't
want to create. Instead, we want to use the default</code>DialogView` as a fallback view.</p>

<h2>Changing the ViewLocator</h2>

<p>Since we want to change the way how views are located, the <code>ViewLocator</code> might
be a good class to look at. The function responsible for locating the view type for
a view model type is called <code>LocateTypeForModelType</code>. In a nutshell, this function takes the
type of the view model and the view context, transforms those into a list of
possible view type names and searches for a type in the assemblies that matches
one of the names. If none is found, <code>null</code> will be returned and Caliburn.Micro
shows the "Could not locate view for ..." error view that you might have seen
before.
``` csharp
public static Func&lt;Type, DependencyObject, object, Type> LocateTypeForModelType = (modelType, displayLocation, context) => {</p>

<pre><code>var viewTypeName = modelType.FullName;

if (Execute.InDesignMode) {
    viewTypeName = ModifyModelTypeAtDesignTime(viewTypeName);
}

viewTypeName = viewTypeName.Substring(
    0,
    viewTypeName.IndexOf("`") &lt; 0
        ? viewTypeName.Length
        : viewTypeName.IndexOf("`")
    );

var viewTypeList = TransformName(viewTypeName, context);
var viewType = viewTypeList.Join(AssemblySource.Instance.SelectMany(a =&gt; a.GetExportedTypes()), n =&gt; n, t =&gt; t.FullName, (n, t) =&gt; t).FirstOrDefault();

if(viewType == null) {
    Log.Warn("View not found. Searched: {0}.", string.Join(", ", viewTypeList.ToArray()));
}

return viewType;
</code></pre>

<p>};
<code>
Now, we basically have two options. Either we replace the function with one that
tries to locate the view without a context when the default function returns
null or we replace the `TransformName` function to also return the type names
without a view context.
I opted for the second options because it is easier to implement and other
function that use `TransformName` benefit from that change, too.
</code> csharp
static readonly Func&lt;string,object, IEnumerable<string>> _baseTransformName = Micro.ViewLocator.TransformName;</p>

<p>static IEnumerable<string> FallbackNameTransform(string typeName, object context)
{</p>

<pre><code>var names = _baseTransformName(typeName, context);
if (context != null)
{
    names = names.Union(_baseTransformName(typeName, null));
}

return names;
</code></pre>

<p>}
<code>``
The implementation is pretty straight-forward. Since the</code>ViewLocator<code>returns the first view type found, we simply append the name(s) of the fallback view(s) to the list of names given by: the default</code>TransformName`.</p>

<h2>Even more customization !</h2>

<p>If you need a different view for <em>Errors</em> and <em>Questions</em>, you might also need
different views for different <em>Questions</em>! Let's say we have views named
<code>My.Namespace.FooQuestion</code> and <code>My.Namespace.BarQuestion</code> which we want to use for different
kinds of Questions. We add a <code>ContextPrefix</code> to the <code>DialogResult</code> and create
the view context by concatenating the <code>ContextPrefix</code> and <code>DialogType</code>. Adding a
fluent configuration for the prefix to the <code>DialogResult</code> gives us this nice
syntax to for showing the <code>FooQuestion</code> view.
``` csharp
public override IEnumerable<IResult> Execute()
{</p>

<pre><code>var question = new Dialog&lt;SpecialAnswer&gt;(DialogType.Question,
    "Why am I so uncreative",
    new SpecialAnswer("Because!"),
    new SpecialAnswer("Dunno."));

yield return question.AsResult()
    .PrefixViewContextWith("Foo");
</code></pre>

<p>}
```</p>

<h2>Appendix</h2>

<h3>I: Note on Namespace aliases</h3>

<p>In case you don't want to put your custom dialog views in the <code>Caliburn.Micro.Contrib.Dialogs</code> namespace, just add a namespace alias the <code>ViewLocator</code>
<code>
ViewLocator.AddSubNamespaceMapping("Caliburn.Micro.Contrib.Dialogs", "My.Namespace.Views");
</code></p>

<h3>II: Online Silverlight Demo</h3>

<p>Although I added an example for this feature to the Silverlight demo, it
currently crashes each browser when embedded in a page. Out-of-browser works
though. If you know why, tell me ! Will update the demo once it works.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CMContrib 1.0 released]]></title>
    <link href="http://kmees.github.com/blog/2012/02/08/cmcontrib-1-dot-0-released/"/>
    <updated>2012-02-08T22:38:00+01:00</updated>
    <id>http://kmees.github.com/blog/2012/02/08/cmcontrib-1-dot-0-released</id>
    <content type="html"><![CDATA[<p>I just uploaded <a href="http://nuget.org/packages/Caliburn.Micro-Contrib">CMContrib 1.0</a> to NuGet. I also created a <a href="/projects/cmcontrib.html">CMContrib project
page</a> with additional info about the features and a Silverlight Demo with samples for each feature.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MVVM Dialogs with Caliburn.Micro]]></title>
    <link href="http://kmees.github.com/blog/2011/06/16/mvvm-dialogs-with-caliburn-dot-micro/"/>
    <updated>2011-06-16T21:10:00+02:00</updated>
    <id>http://kmees.github.com/blog/2011/06/16/mvvm-dialogs-with-caliburn-dot-micro</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>In every applications life there comes a time when you need to show some kind of message to the user. Be it a question whether he really wants to delete something or a simple message that says that some operation was successful. The most simple way to do that is the good ol' <code>MessageBox.Show()</code> with its zillion overloads.</p>

<p><code>csharp
MessageBox.Show("Foo", "Bar", MessageBoxButton.OKCancel);
</code></p>

<p>But in the shiny MVVM World , polluting your ViewModels with MessageBoxes is usually frowned upon since it breaks a lot of stuff, especially automated unit testing and theming.</p>

<p>You can find quite a lot solutions about how the MVVM<em>ize</em> MesasgeBoxes and dialog screens in general. Most of them involve wrapping the <code>MessageBox.Show()</code> in some kind of IService, setting up some kind of event infrastructure and other funky stuff. Surprisingly, all of those solutions completely ignore the first M in <strong>M</strong>VVM, namely the Model, and none really tackles the problem at its heart.</p>

<!--more-->


<h2>Implementation</h2>

<h3>One Model to rule them all</h3>

<p>Well, let's forget about all the View and ViewModel stuff for now. We will start by specifying what we actually want to achieve with a dialog.</p>

<p>We want to display some message concerning some topic and a list of possible Responses from which the user can choose one.</p>

<p>So, let's create a model with conforms to those specifications</p>

<p>``` csharp Dialog&lt;TResponse&gt;
public class Dialog<TResponse>
{</p>

<pre><code>public DialogType DialogType { get; set; }
public string Subject { get; set; }
public string Message { get; set; }

public IEnumerable&lt;TResponse&gt; PossibleResponses { get; protected set; }
public TResponse GivenResponse {get; set; }
public bool IsResponseGiven { get; private set; }
</code></pre>

<p>}
```</p>

<p>``` csharp DialogType
public enum DialogType
{</p>

<pre><code>None,
Question,
Warning,
Information,
Error
</code></pre>

<p>}
```</p>

<p>The DialogType in conjunction with the subject defines the topic and the rest is pretty much straightforward. We also need a IsResponseGiven Property so that we can distinguish between default and unset values because TResponse may or may not be a value type (and hence not nullable).</p>

<h3>One ViewModel to bind them</h3>

<p>The ViewModel is responsible for bringing the Responses in a bindable format and setting the response on the dialog when the user selects one. The ViewModel also handles the case where the user closes the window without giving any response at all.</p>

<p>For supporting default (the user presses <code>Enter</code>) and cancel (the user presses <code>Escape</code>) responses,  I will use a convention based approach, namely defining the first response in the list as the default response and the last response as the cancel response.</p>

<p>``` csharp BindableResponse&lt;TResponse&gt;
public class BindableResponse<TResponse>
{</p>

<pre><code>public TResponse Response { get; set; }
public bool IsDefault { get; set; }
public bool IsCancel { get; set; }
</code></pre>

<p>}
```</p>

<p>``` csharp IDialogViewModel&lt;TResponse&gt;
public interface IDialogViewModel<TResponse>
{</p>

<pre><code>bool IsClosed { get; set; }
Dialog&lt;TResponse&gt; Dialog { get; set; }
IObservableCollection&lt;BindableResponse&lt;TResponse&gt;&gt; Responses { get; }
void Respond(BindableResponse&lt;TResponse&gt; bindableResponse);
</code></pre>

<p>}
```</p>

<p>The implementation is pretty straightforward and omitted for brevity but can be found here.</p>

<h3>One View to show them all</h3>

<p>I will present the WPF version of the view here because the SL version requires a workaround for the non existing <code>IsDefault</code>/<code>IsCancel</code> Properties of the Button. For those interested in the SL version, the source is here. I will also omit all irrelevant (styling) properties.</p>

<p>``` xml DialogView
&lt;Window x:Class="Caliburn.Micro.Contrib.Interaction.DialogView"</p>

<pre><code>    Title="{Binding Dialog.Subject}"
    Contrib:DialogCloser.DialogResult="{Binding CanClose}"&gt;
&lt;Window.Icon&gt;
    &lt;Binding Path="Dialog.DialogType"&gt;
        &lt;Binding.Converter&gt;
            &lt;Converter:DialogTypeToSystemIconConverter /&gt;
        &lt;/Binding.Converter&gt;
    &lt;/Binding&gt;
&lt;/Window.Icon&gt;
&lt;DockPanel Focusable="False" LastChildFill="True"&gt;
    &lt;ItemsControl x:Name="Responses"&gt;
        &lt;ItemsControl.ItemTemplate&gt;
            &lt;DataTemplate&gt;
                &lt;Button Content="{Binding Response}"
                        IsCancel="{Binding IsCancel}"
                        IsDefault="{Binding IsDefault}"
                        Micro:Message.Attach="Respond($dataContext)" /&gt;
            &lt;/DataTemplate&gt;
        &lt;/ItemsControl.ItemTemplate&gt;
    &lt;/ItemsControl&gt;
    &lt;TextBlock Text="{Binding Dialog.Message}" /&gt;
&lt;/DockPanel&gt;
</code></pre>

<p></Window>
```</p>

<p>The most important part is where we bind the Responses to an ItemsControl (by using Caliburn.Micros Convention Binding Feature) and create a Button for each Response which will call the Respond() Method on the ViewModel with the bound Response as a parameter. The Subject of the Dialog is bound to the Title of the Window and the DialogType is converted to an Icon.</p>

<h3>And with the IResult show them</h3>

<p>No Caliburn.Micro Extension with the corresponding IResult to use them !</p>

<p>To actually show the dialog to the user, we would have to</p>

<ul>
<li>Create the dialog</li>
<li>Import the IWindowManager in the ViewModel</li>
<li>Create the ViewModel and pass it the dialog</li>
<li>Invoke ShowDialog() on the IWindowManager with the ViewModel as a parameter</li>
</ul>


<p>Well, the first step cannot be encapsulated in an IResult, but 2-4 rest can easily be encapsulated.</p>

<p>``` csharp DialogResult&lt;TResponse&gt;
public class DialogResult<TResponse> : IResult
{</p>

<pre><code>private Func&lt;IDialogViewModel&lt;TResponse&gt;&gt; _locateVM =
    () =&gt; new DialogViewModel&lt;TResponse&gt;();

public DialogResult(Dialog&lt;TResponse&gt; dialog)
{
    Dialog = dialog;
}

public Dialog&lt;TResponse&gt; Dialog { get; private set; }

public void Execute(ActionExecutionContext context)
{
    IDialogViewModel&lt;TResponse&gt; vm = _locateVM();
    vm.Dialog = Dialog;
    Micro.Execute.OnUIThread(() =&gt; IoC.Get&lt;IWindowManager&gt;().ShowDialog(vm));
}

public DialogResult&lt;TResponse&gt; In(IDialogViewModel&lt;TResponse&gt; dialogViewModel)
{
    _locateVM = () =&gt; dialogViewModel;
    return this;
}

public DialogResult&lt;TResponse&gt; In&lt;TDialogViewModel&gt;()
    where TDialogViewModel : IDialogViewModel&lt;TResponse&gt;
{
    _locateVM = () =&gt; IoC.Get&lt;TDialogViewModel&gt;();
    return this;
}
</code></pre>

<p>}
```</p>

<p>We do not only get reusable code, but also a nice way to change the implementation of IDialogViewModel&lt;> for specific dialogs if we want to.</p>

<p>Last but not least we can write a small Extension Method to get even more readable code !</p>

<p>``` csharp
public static DialogResult<TResponse> AsResult<TResponse>(this Dialog<TResponse> dialog)</p>

<pre><code>    {
        return new DialogResult&lt;TResponse&gt;(dialog);
    }
</code></pre>

<p>```</p>

<p>And use it in the coroutine</p>

<p>``` csharp Demo
public IEnumerable<IResult> Foo()
{</p>

<pre><code>var question = new Dialog&lt;Answer&gt;(DialogType.Question,
                                  "Isn't this a nice way to create a Dialog Window?",
                                  Answer.Yes,
                                  Answer.No);

yield return question.AsResult();

if (question.GivenResponse == Answer.Yes)
    Console.WriteLine(" ^_^ ");
else
    Console.WriteLine(" :*( ");
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
